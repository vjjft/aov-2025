
use #util::io::{ln, log};
use #util::n32::digit_char;

pub fn main(&io: &IO) {
  let part1 = 0[N64];
  let part2 = 0[N64];

  let num__: List[List[N32]] = [];
  while io.read_line() is Some(line) {
    let num_ = line!.map(fn* (c: Char) { N32::parse(c as String).assume() });
    num__.push_back(num_)
  }

  let fn* part1_process(num_: List[N32]) {
    assert (num_.pop_front(), num_.pop_front()) is (Some(a), Some(b)) else {}

    while num_.pop_front() is Some(c) {
      when {
        a < b {
          a = b;
          b = c;
        }
        b < c {
          b = c;
        }
      }
    }
    io.log((a, b));

    let joltage = a * 10 + b;
    part1 += joltage;
  }

  let fn* part2_process(num_: List[N32]) {
    assert num_.split_at(12) is (active, rest) else {}

    // io.log({ active, rest })

    while rest.pop_front() is Some(x) {
      assert active.pop_front() is Some(a) else { debug::error("") }

      // io.ln();
      // io.log({ x })
      let temp_active = active ++ [x];
      let new_active = List::empty[N32];
      while temp_active.pop_front() is Some(b) {
        // io.log([new_active, [a], [b], temp_active, [x]])
        when {
          a >= b {
            new_active ++= [a];
            a = b
          }
          _ {
            new_active ++= [b] ++ temp_active;
            break;
          }
        }
      } else {
        // new_active ++= [a]
      }
      active = new_active
      // io.log({ active, len: active.len() });
      assert active.len() == 12 else { debug::error("bad active length") }
      // io.ln();
    }

    let char_ = active.map(digit_char);
    // io.log(char_)
    let joltage_string: String = char_ as String;
    // io.log(joltage_string)
    assert N64::parse(joltage_string) is Some(joltage) else { debug::error("") }
    io.log(joltage)

    part2 += joltage;
  }

  io.log(("num__", num__))
  for num_ in num__.iter() {
    part1_process(num_)
    part2_process(num_)
  }

  io.println("Part 1: {part1}");

  io.println("Part 2: {part2}");
}
