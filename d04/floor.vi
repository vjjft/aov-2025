
use #util::Channel;
use #root::ops::Cast;
use #root::data::Map;

pub mod roll = "./roll.vi";
use roll::{Chan, Roll, RollState};

pub mod dir = "./dir.vi";
use dir::Dir;

pub struct? Floor(pub { grid: List[&List[Option[&Roll]]], map: Map[N64, &Roll] });
pub mod Floor {
  pub fn parse_input(&io: &IO) -> Floor {
    let floor = Floor({ grid: [], map: Map::empty[N64, &Roll] });

    let row_above: List[Option[&Roll]] = [];
    let x_nw: Option[&Roll] = None();
    let x_w_: Option[&Roll] = None();

    let n = 0[N64];
    let fn* init_roll(c: Char) -> Option[Roll] {
      let roll = Roll::parse_char_assume(c);
      let x_n_ = row_above.pop_front().flatten();
      let x_ne = row_above.get(0).flatten();

      if (roll!.state!) {
        roll!.id = Some(do {
          n += 1;
          n
        })

        if x_nw is Some(&x_nw) {
          let (a, b) = init_channel_pair();
          roll.nh.insert(Dir::NW(), a);
          x_nw.nh.insert(Dir::SE(), b);
        }
        if x_n_ is Some(&x_n_) {
          let (a, b) = init_channel_pair();
          roll.nh.insert(Dir::N_(), a);
          x_n_.nh.insert(Dir::S_(), b);
        }
        if x_ne is Some(&x_ne) {
          let (a, b) = init_channel_pair();
          roll.nh.insert(Dir::NE(), a);
          x_ne.nh.insert(Dir::SW(), b);
        }
        if x_w_ is Some(&x_w_) {
          let (a, b) = init_channel_pair();
          roll.nh.insert(Dir::W_(), a);
          x_w_.nh.insert(Dir::E_(), b);
        }
      }

      x_nw = x_n_;
      if (roll!.state!) {
        x_w_ = Some(&roll);
        Some(roll)
      } else {
        x_w_ = None();
        None()
      }
    }
    while io.read_line() is Some(line) {
      let row = [];
      while line!.pop_front() is Some(c) {
        let opt_roll = init_roll(c);
        row ++= [opt_roll.as_ref()];
        assert opt_roll is Some(roll) else {
          continue;
        }
        floor!.map.insert(roll!.id.assume(), &roll);
      }
      x_nw = None();
      x_w_ = None();
      row_above = row
      // floor!.grid.push_back(&row)
    }
    floor
  }

  pub fn .notify(&floor: &Floor) {
    floor.apply(Roll::notify)
  }

  pub fn .apply[F*; fn F(&Roll) -> ()](&floor: &Floor, f: F) {
    for &(_, &roll) in floor!.map.iter_ref() {
      f(&roll)
    }
  }

  pub fn .count_can_lift(&floor: &Floor) -> N64 {
    let count = 0[N64];
    let fn* check_can_lift(&roll: &Roll) {
      if !roll.state! {
        return;
      }
      if (4 > roll.count_neighbor_rolls()) {
        count += 1
      }
    }
    floor.apply(check_can_lift)
    count
  }

  pub fn .lift(&floor: &Floor) -> N64 {
    let count = 0[N64];
    let fn* try_lift(&roll: &Roll) {
      if !roll.state! {
        return;
      }
      if (4 > roll.count_neighbor_rolls()) {
        roll!.state! = false;
        // floor!.map.remove(&roll!.id.assume());
        count += 1
      }
    }
    floor.apply(try_lift)
    count
  }

  fn init_channel_pair() -> (Chan, Chan) {
    Channel::new_pair[RollState]()
  }

  pub impl to_string: Cast[&Floor, String] {
    fn cast(&floor: &Floor) -> String {
      let str = "";
      let fn* roll_char(o: Option[&Roll]) {
        let char = match (o) {
          None() { '-' }
          Some(&roll) { &roll as Char }
        };

        str!.push_back(char);
      }
      for &&row in floor!.grid.iter_ref() {
        for roll in row.iter() {
          roll_char(roll)
        }
        str!.push_back('\n');
      }
      str
    }
  }

  pub impl show: Show[Floor];
}
