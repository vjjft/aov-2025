
use #util::{list::is_constant, log, n64::{has_even_places, is_even, order, places}, string::chunk};

use #root::debug::log as dbg;
use #root::IO::println as out;

pub fn main(&io: &IO) {
  assert io.read_line() is Some(input) else { debug::error("bad input") }
  input ++= ","

  let range_: List[(String, String)] = [];

  let part1 = 0[N64];
  let part2 = 0[N64];

  while input.len() > 1 {
    // dbg(input);

    let rest = input;
    assert rest.split_once("-") is (start, Some(rest)) else {
      debug::error("failed to parse {input}")
    }
    // dbg("start: {start}");

    assert rest.split_once(",") is (end, Some(rest)) else {
      debug::error("failed to parse {input}")
    }
    // dbg("end:   {end}");

    // io.log("range: {(start, end).show()}");
    range_.push_back((start, end));
    input = rest;
    assert N64::parse(start) is Some(from) else { debug::error("failed to parse start: {start}") }
    assert N64::parse(end) is Some(to) else { debug::error("failed to parse end: {end}") }

    io.log("range: {(from, to).show()}");

    io.println((from.places(), to.places()).show() as String)
    let skip_part1_invalid_ranges = true;
    let skip_part1_invalid_ranges = false;
    if (skip_part1_invalid_ranges) {
      if from.order() == to.order() and !from.has_even_places() {
        io.log("skip");
        continue;
      }
    }
    // continue;

    let fn* exec_part1(n: N64) -> () {
      do {
        if !n.has_even_places() {
          return;
        }

        let num = n as String;
        let half_places = n.places() / 2;

        assert num.split_at(half_places) is (sub_a, sub_b) and sub_a == sub_b is valid else {
          return;
        }

        // io.println("{valid}: {num}");

        if (!valid) {
          return;
        }

        part1 += n;
      }
    }

    let fn* exec_part2(n: N64) -> () {
      do {
        let num = n as String;

        let fn* part2_add() {
          part2 += n
        }

        let fn* part2_handle(valid: Bool) {
          let show = true;
          let show = valid;
          if (show) {
            io.println("{valid}: {num}");
          }
          if (valid) {
            part2_add()
          }
        }
        let fn* part2_check_sub(num: String, c: N32) -> Bool {
          assert num.chunk(c, true) is (chunk_, _) else { debug::error("") }

          let valid = chunk_.is_constant() is Ok(_);
          if (valid) {
            part2_handle(valid);
          }
          valid
        }
        let p = num.len();

        when {
          p == 10 {
            if part2_check_sub(num, 5) {
              return;
            }
            if part2_check_sub(num, 2) {
              return;
            }
          }
          p == 9 {
            if part2_check_sub(num, 3) {
              return;
            }
          }
          p == 8 {
            if part2_check_sub(num, 4) {
              return;
            }
            if part2_check_sub(num, 2) {
              return;
            }
          }
          p == 6 {
            if part2_check_sub(num, 3) {
              return;
            }
            if part2_check_sub(num, 2) {
              return;
            }
          }
          p == 4 {
            if part2_check_sub(num, 2) {
              return;
            }
          }
          p == 1 {
            part2_handle(false);
            return;
          }
        }
        if part2_check_sub(num, 1) {
          return;
        }
        part2_handle(false);
      }
    }

    for n in from..(to + 1) {
      exec_part1(n);
      exec_part2(n);
    }
  }

  // dbg(range_.show());

  io.println("");

  io.println("Part 1: {part1}");

  io.println("Part 2: {part2}");
}
