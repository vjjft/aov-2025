
use #util::{is_even, log};

use #root::debug::log as dbg;
use #root::IO::println as out;

pub fn main(&io: &IO) {
  assert io.read_line() is Some(input) else { debug::error("bad input") }
  input ++= ","

  let range_: List[(String, String)] = [];

  let part1 = 0[N64];

  while input.len() > 1 {
    // dbg(input);

    let rest = input;
    assert rest.split_once("-") is (start, Some(rest)) else {
      debug::error("failed to parse {input}")
    }
    // dbg("start: {start}");

    assert rest.split_once(",") is (end, Some(rest)) else {
      debug::error("failed to parse {input}")
    }
    // dbg("end:   {end}");

    // io.log("range: {(start, end).show()}");
    range_.push_back((start, end));
    input = rest;
    assert N32::parse(start) is Some(from) else { debug::error("failed to parse start: {start}") }
    assert N32::parse(end) is Some(to) else { debug::error("failed to parse end: {end}") }

    io.log("range: {(from, to).show()}");

    fn .has_even_digits(n: N32) -> Bool {
      !n.log(10).is_even()
    }

    fn .digits(n: N32) -> N32 {
      n.log(10) + 1
    }

    let skip_invalid_ranges = true;
    if (skip_invalid_ranges) {
      if !from.has_even_digits() and !to.has_even_digits() {
        io.log("skip");
        continue;
      }
    }
    io.println((from.digits(), to.digits()).show() as String)
    // continue;

    for n in from..(to + 1) {
      if !n.has_even_digits() {
        continue;
      }

      let num = n as String;
      let half_digits = n.digits() / 2;

      assert num.split_at(half_digits) is (sub_a, sub_b) and sub_a == sub_b else {
        continue;
      }

      part1 += n;
    }
  }

  // dbg(range_.show());

  io.println("");

  io.println("Part 1: {part1}");

  let part2 = 0;
  io.println("Part 2: {part2}");
}
