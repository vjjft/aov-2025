
pub fn main(&io: &IO) {
  let position = 50;
  let running = position;
  let hits = 0;
  let passes = 0;

  while io.read_line() is Some(turn) {
    assert turn!.head_tail() is Some(dir, num) else { debug::error("bad input") }
    assert N32::parse(String(num)) is Some(n) else { debug::error("bad input") }

    let spins = n / 100;
    let net = n % 100;

    passes += spins;

    let start = position;
    let temp = position as I32;

    when {
      dir == 'R' {
        temp += +net;
      }
      _ {
        temp -= +net;
      }
    };

    let poss_pass = false;
    when {
      temp < +0 {
        poss_pass = true;
        position = (temp + +100) as N32;
      }
      temp > +100 {
        poss_pass = true;
        position = (temp - +100) as N32;
      }
      temp == +0 {
        poss_pass = true;
        hits += 1;
        position = temp as N32;
      }
      temp == +100 {
        poss_pass = true;
        hits += 1;
        position = (temp - +100) as N32;
      }
      _ {
        position = temp as N32;
      }
    }

    if poss_pass and start != 0 {
      passes += 1
    }

    // (start, turn, spins, temp, position, (hits, passes)).dbg();
  };

  let part1 = hits;
  io.println("Part 1: {part1}");

  let part2 = passes;
  io.println("Part 2: {part2}");
}
